好的，收到。既然必须严格走 **Claude CLI** 通道（利用其 Code Plans 的保护机制和计费逻辑），那么 AgentFlow 的定位就非常明确了：**Rust 是“指挥官”和“情报官”，Claude CLI 是“执行士兵”。**
所有 Issue 的核心逻辑都改为：**Rust 负责准备环境、收集情报（索引）、组装 Prompt，最后扔给 CLI 去跑。**
以下是重新整理好的 Issue，你可以直接发给 Agent。
---
## Issue #1: 强制 Feature Branch 工作流与 CLI 执行隔离
**标签**: `workflow`, `cli-wrapper`, `git`
**背景与约束**:
所有代码修改必须通过 `claude` CLI 执行。为了保护 `main` 分支，必须在 Rust 侧控制 Git 流程，确保 CLI 运行在隔离的 Feature 分支上。
**实现步骤**:
1.  **前置 Hook (Rust)**:
    -   在调用 `CliRunner::execute` 之前，Rust 执行：
        ```bash
        git checkout main
        git pull
        git checkout -b agentflow/task-{timestamp}
        ```
2.  **CLI 执行**:
    -   在此新分支下，Rust 启动 `claude -p "..."` 进程。
    -   Prompt 中注入提示：“当前处于 feature 分支，请直接进行代码修改和测试。”
3.  **后置清理 (Rust)**:
    -   监控 CLI 进程退出码。
    -   **失败场景**：若 CLI 报错或任务失败，Rust 执行回滚：
        ```bash
        git checkout main
        git branch -D agentflow/task-{timestamp}
        ```
    -   **成功场景**：保留分支，或可选地执行 `git push`。
**验收标准**:
-   Rust 日志显示 CLI 启动前已切换到新分支。
-   任务失败后，`git branch` 列表中无残留的 agentflow 分支。
-   `main` 分支始终保持干净状态。
---
## Issue #2: 基于 CLI 的并行任务编排 (DAG Scheduler)
**标签**: `core`, `scheduler`, `cli-distribution`
**背景与约束**:
云端 Master 负责任务拆分，但具体执行必须分发给各节点的 `claude` CLI 进程。
**实现步骤**:
1.  **云端 Planner (Rust)**:
    -   Planner 调用轻量级 CLI 生成 DAG JSON（包含 `task_id`, `target_node`, `deps`）。
2.  **任务分发器 (Rust)**:
    -   Cloud Master 解析 DAG。
    -   对于无依赖的任务，通过 HTTP 并发发送给对应的 Edge Node。
3.  **边缘节点执行 (Rust -> CLI)**:
    -   Edge Node 收到任务后，启动本地的 `claude` CLI 进程。
    -   任务状态（运行中/完成/失败）实时回传给 Cloud Master。
4.  **依赖触发**:
    -   Cloud Master 监听任务状态，当 `t1`, `t2` 完成后，自动下发 `t3` 给对应节点。
**验收标准**:
-   Cloud Master 能同时调度 Windows 节点和 Linux 节点运行 CLI。
-   依赖逻辑严格：前置任务失败，后续任务不应触发。
-   所有底层操作均由 `claude` 完成，Rust 仅做管道转发。
---
## Issue #3: 动态技能清单注入
**标签**: `prompt-engineering`, `cli-integration`
**背景与约束**:
不通过 API 定义 Function，而是通过 Rust 读取 `skills.json`，将其转化为 **Prompt 描述**，强制 CLI 使用标准化的命令。
**实现步骤**:
1.  **技能定义**:
    -   项目根目录维护 `skills.json`：
        ```json
        {
          "compile": {
            "desc": "编译项目",
            "cmd_template": "msbuild {project}.sln /p:Config={config}"
          }
        }
        ```
2.  **Prompt 组装**:
    -   Rust 的 `PromptBuilder` 读取 JSON。
    -   将其转换为严格的 System Prompt 指令：
        ```markdown
        ## Available Skills
        你必须使用以下预定义技能，严禁自己发明命令：
        1. Compile: 执行 "msbuild {project}.sln /p:Config={config}"
        ```
3.  **CLI 执行**:
    -   Rust 将组装好的 Prompt 传给 `claude -p`。
    -   CLI (LLM) 根据 Prompt 指令，调用 Bash 工具执行对应的命令。
**验收标准**:
-   LLM 在修改代码时，准确使用了 `skills.json` 中定义的命令参数。
-   若 Prompt 中未包含某技能，LLM 不会尝试执行相关操作。
-   全程无 API 调用，完全依赖 CLI 的理解能力。
---
## Issue #4: Tree-sitter 符号索引与 Context 增强上下文
**标签**: `performance`, `code-intelligence`, `context-builder`
**背景与约束**:
为了减少 CLI 的 Token 消耗并提高精准度，Rust 需要预计算代码位置，将“代码片段”直接喂给 CLI，而不是让 CLI自己去搜索。
**实现步骤**:
1.  **离线索引 (Rust)**:
    -   集成 `tree-sitter`，扫描项目代码，建立 SQLite 索引表 `code_symbols(symbol_name, file_path, line_range)`。
2.  **查询增强**:
    -   当用户任务涉及“修改 X 函数”时，Rust 先查表。
    -   读取该函数对应的源代码片段（约 50-100 行）。
3.  **Prompt 注入**:
    -   将代码片段作为 `<context_snippet>` 塞入 Prompt：
        ```markdown
        ## Context
        这是你需要修改的目标代码：
        <file_path>src/render.cpp</file_path>
        <content>
        ...code...
        </content>
        ```
4.  **CLI 执行**:
    -   启动 `claude -p`，LLM 基于提供的代码片段直接进行 Edit 操作，无需执行耗时的 `grep` 或文件搜索。
**验收标准**:
-   符号索引查询在毫秒级完成。
-   CLI 输出的日志中显示它直接使用了提供的代码片段，而非自己搜索文件。
-   对于大型项目，Token 占用量显著降低。
