# v0.3.0 迭代计划：智谱清言接入与大屏监控

**版本**: v0.3.0
**目标**: 补全交互闭环，实现"随时接入"与"可视运行"
**状态**: 计划中
**预计工期**: 10-14 天

---

## 版本目标

### 核心目标
1. **输入端**：接入智谱清言智能体，作为手机/语音指令网关
2. **输出端**：构建大屏监控，实时展示节点状态与 CLI 执行日志

### 核心约束
- 所有代码执行**必须**通过本地 `claude cli` 完成，Rust 仅负责调度与上下文管理
- 智谱清言仅作为指令传输通道，不参与具体的代码生成与执行

---

## 实施路线图

### Phase 1: Webhook 接入 (MVP)
**目标**: 能通过智谱清言触发本地简单任务
**工期**: 2-3 天
**优先级**: P0

### Phase 2: 基础大屏 (Tauri)
**目标**: 能在电脑上看到节点状态和静态日志
**工期**: 3-4 天
**优先级**: P1

### Phase 3: 实时流传输
**目标**: 大屏能实时滚动显示 CLI 执行过程
**工期**: 2-3 天
**优先级**: P1

### Phase 4: 记忆可视化 (可选)
**目标**: 数据层可视化
**工期**: 2 天
**优先级**: P2

---

## Phase 1: Webhook 接入

### 1.1 任务拆解

#### Task 1.1: 实现 Webhook Server
**文件**: `rust/agentflow-master/src/webhook/mod.rs`
**工作量**: 0.5 天

**实现内容**:
```rust
// webhook/mod.rs
pub mod zhipu;
pub mod auth;

use axum::{
    Router,
    routing::post,
    Extension,
};

pub fn webhook_router() -> Router {
    Router::new()
        .route("/api/v1/webhook/zhipu", post(zhipu::handle_webhook))
        .layer(Extension(auth::WebhookAuth::new()))
}
```

**验收标准**:
- Webhook 路由注册成功
- 能接收 POST 请求
- 返回 200 OK

---

#### Task 1.2: 实现鉴权中间件
**文件**: `rust/agentflow-master/src/webhook/auth.rs`
**工作量**: 0.5 天

**实现内容**:
```rust
// webhook/auth.rs
use axum::{
    extract::Request,
    http::{HeaderMap, StatusCode},
    middleware::Next,
    response::Response,
};

pub struct WebhookAuth {
    secret: String,
    allowed_ips: Vec<String>,
}

impl WebhookAuth {
    pub fn new() -> Self {
        Self {
            secret: std::env::var("WEBHOOK_SECRET")
                .unwrap_or_else(|_| "default_secret".to_string()),
            allowed_ips: vec![
                "智谱服务器IP".to_string(), // TODO: 替换为真实IP
            ],
        }
    }

    pub async fn verify(
        &self,
        headers: HeaderMap,
        source_ip: &str,
    ) -> Result<(), StatusCode> {
        // 1. Token 校验
        let auth = headers
            .get("Authorization")
            .ok_or(StatusCode::UNAUTHORIZED)?;

        if auth != &format!("Bearer {}", self.secret) {
            return Err(StatusCode::FORBIDDEN);
        }

        // 2. IP 白名单校验（可选）
        if !self.allowed_ips.is_empty() {
            if !self.allowed_ips.contains(&source_ip.to_string()) {
                return Err(StatusCode::FORBIDDEN);
            }
        }

        Ok(())
    }
}
```

**验收标准**:
- 无 Token：返回 401 Unauthorized
- Token 错误：返回 403 Forbidden
- Token 正确：通过校验

---

#### Task 1.3: 实现智谱清言 Webhook 处理
**文件**: `rust/agentflow-master/src/webhook/zhipu.rs`
**工作量**: 1 天

**实现内容**:
```rust
// webhook/zhipu.rs
use axum::{
    extract::{State, Extension},
    http::HeaderMap,
    Json,
};
use serde::{Deserialize, Serialize};
use crate::executor::TaskExecutor;

#[derive(Debug, Deserialize)]
pub struct ZhipuWebhookRequest {
    pub text: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ZhipuWebhookResponse {
    pub task_id: String,
    pub status: String,
    pub message: String,
}

pub async fn handle_webhook(
    State(executor): State<TaskExecutor>,
    headers: HeaderMap,
    Json(payload): Json<ZhipuWebhookRequest>,
) -> Result<Json<ZhipuWebhookResponse>, StatusCode> {
    // 1. 验证签名/权限
    // (在中间件中已完成)

    // 2. 调用 CLI 解析意图
    let intent = parse_intent_with_cli(&payload.text).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // 3. 任务分发
    let task_id = executor.dispatch_task(intent).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // 4. 返回响应
    Ok(Json(ZhipuWebhookResponse {
        task_id,
        status: "dispatched".to_string(),
        message: "任务已下发".to_string(),
    }))
}

#[derive(Debug, Deserialize)]
struct Intent {
    target_node: String,
    repo: String,
    risk_level: String,
    steps: Vec<String>,
}

async fn parse_intent_with_cli(text: &str) -> Result<Intent, anyhow::Error> {
    use std::process::Command;

    // 构建针对 Planner 的 Prompt
    let prompt = format!(
        r#"你是任务规划器。请将以下用户指令解析为结构化 JSON：

用户指令: {}

请返回 JSON 格式：
{{
  "target_node": "目标节点名称",
  "repo": "仓库名称",
  "risk_level": "风险等级 (low/medium/high)",
  "steps": ["步骤1", "步骤2", ...]
}}

仅返回 JSON，不要其他内容。"#,
        text
    );

    // 调用 Claude CLI
    let output = Command::new("claude")
        .args(["--prompt", &prompt])
        .output()
        .await?;

    if !output.status.success() {
        anyhow::bail!("CLI 调用失败");
    }

    let json_str = String::from_utf8_lossy(&output.stdout);
    let intent: Intent = serde_json::from_str(&json_str)?;

    Ok(intent)
}
```

**验收标准**:
- 接收智谱清言 Webhook 请求
- 调用 CLI 解析意图
- 返回 task_id
- 错误处理完善

---

#### Task 1.4: 配置测试
**文件**: `tests/webhook_test.sh`
**工作量**: 0.5 天

**实现内容**:
```bash
#!/bin/bash
# 测试 Webhook 接口

WEBHOOK_URL="http://localhost:6767/api/v1/webhook/zhipu"
SECRET="test_secret"

# 测试 1: 无 Token
curl -X POST "$WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -d '{"text":"测试指令"}' \
  -v

# 预期: 401 Unauthorized

# 测试 2: 错误 Token
curl -X POST "$WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer wrong_secret" \
  -d '{"text":"测试指令"}' \
  -v

# 预期: 403 Forbidden

# 测试 3: 正确 Token
curl -X POST "$WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $SECRET" \
  -d '{"text":"跑个测试"}' \
  -v

# 预期: 200 OK + task_id
```

**验收标准**:
- 所有测试用例通过
- 返回正确的 task_id

---

### 1.2 Phase 1 验收标准

- ✅ Webhook 接口正常运行
- ✅ 鉴权机制有效
- ✅ 能通过智谱清言触发任务
- ✅ 返回正确的 task_id

---

## Phase 2: 基础大屏 (Tauri)

### 2.1 技术选型

**框架**: Tauri 1.x
**前端**: React + TypeScript
**UI 库**: Ant Design (或 Material-UI)
**图形库**: React Flow (拓扑图)

### 2.2 任务拆解

#### Task 2.1: 搭建 Tauri 项目
**目录**: `desktop/dashboard/`
**工作量**: 0.5 天

**实现步骤**:
```bash
# 1. 安装 Tauri CLI
cargo install tauri-cli

# 2. 创建项目
cd desktop
npm create tauri-app@latest

# 3. 配置 Tauri
# src-tauri/Cargo.toml
[dependencies]
agentflow-core = { path = "../../rust/agentflow-core" }
agentflow-master = { path = "../../rust/agentflow-master" }
```

**验收标准**:
- Tauri 应用能正常启动
- 显示空白窗口

---

#### Task 2.2: 实现节点状态 API
**文件**: `rust/agentflow-master/src/api/nodes.rs`
**工作量**: 0.5 天

**实现内容**:
```rust
// api/nodes.rs
use axum::{
    extract::State,
    Json,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeStatus {
    pub id: String,
    pub os: String,
    pub version: String,
    pub status: String, // "online" | "offline" | "busy"
    pub cpu_load: f32,
    pub memory_usage: u64,
    pub active_tasks: Vec<String>,
}

pub async fn get_nodes(
    State(executor): State<TaskExecutor>,
) -> Json<Vec<NodeStatus>> {
    let nodes = executor.get_all_nodes().await;

    Json(nodes.into_iter().map(|node| NodeStatus {
        id: node.id,
        os: node.os,
        version: node.version,
        status: if node.is_active {
            if node.active_tasks.is_empty() {
                "online".to_string()
            } else {
                "busy".to_string()
            }
        } else {
            "offline".to_string()
        },
        cpu_load: node.cpu_load,
        memory_usage: node.memory_usage,
        active_tasks: node.active_tasks,
    }).collect())
}
```

**验收标准**:
- `GET /api/v1/nodes` 返回节点列表
- 包含节点状态信息

---

#### Task 2.3: 实现节点拓扑图
**文件**: `desktop/dashboard/src/components/NodeTopology.tsx`
**工作量**: 1.5 天

**实现内容**:
```tsx
import React, { useEffect, useState } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Background,
  Controls,
  MiniMap,
} from 'reactflow';
import 'reactflow/dist/style.css';

interface NodeStatus {
  id: string;
  os: string;
  status: string;
  cpu_load: number;
  active_tasks: string[];
}

export const NodeTopology: React.FC = () => {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);

  useEffect(() => {
    // 获取节点状态
    fetch('http://localhost:6767/api/v1/nodes')
      .then(res => res.json())
      .then((data: NodeStatus[]) => {
        // 构建拓扑图
        const masterNode: Node = {
          id: 'master',
          type: 'default',
          data: { label: 'Cloud Master' },
          position: { x: 400, y: 100 },
        };

        const edgeNodes = data.map((node, index) => ({
          id: node.id,
          type: 'default',
          data: {
            label: `${node.id} (${node.status})`,
          },
          position: { x: 200 + index * 300, y: 300 },
          style: {
            backgroundColor: node.status === 'online' ? '#90EE90' :
                           node.status === 'busy' ? '#FFD700' :
                           '#FFB6C1',
          },
        }));

        const edges = data.map(node => ({
          id: `master-${node.id}`,
          source: 'master',
          target: node.id,
          type: 'smoothstep',
          animated: node.status === 'busy',
        }));

        setNodes([masterNode, ...edgeNodes]);
        setEdges(edges);
      });
  }, []);

  return (
    <div style={{ width: '100%', height: '600px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        fitView
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
};
```

**验收标准**:
- 显示节点拓扑图
- 在线节点绿色，忙碌节点黄色，离线节点红色
- 连线动画（忙碌时）

---

#### Task 2.4: 实现任务列表
**文件**: `desktop/dashboard/src/components/TaskList.tsx`
**工作量**: 1 天

**实现内容**:
```tsx
import React, { useEffect, useState } from 'react';
import { Table } from 'antd';

interface Task {
  id: string;
  prompt: string;
  status: string;
  node_id: string;
  created_at: string;
}

export const TaskList: React.FC = () => {
  const [tasks, setTasks] = useState<Task[]>([]);

  useEffect(() => {
    // 轮询任务列表
    const interval = setInterval(() => {
      fetch('http://localhost:6767/api/v1/tasks')
        .then(res => res.json())
        .then(setTasks);
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  const columns = [
    { title: 'Task ID', dataIndex: 'id', key: 'id' },
    { title: 'Prompt', dataIndex: 'prompt', key: 'prompt' },
    { title: 'Status', dataIndex: 'status', key: 'status' },
    { title: 'Node', dataIndex: 'node_id', key: 'node_id' },
    { title: 'Created At', dataIndex: 'created_at', key: 'created_at' },
  ];

  return <Table dataSource={tasks} columns={columns} />;
};
```

**验收标准**:
- 显示任务列表
- 每 5 秒自动刷新

---

### 2.3 Phase 2 验收标准

- ✅ Tauri 应用正常启动
- ✅ 显示节点拓扑图
- ✅ 显示任务列表
- ✅ 点击节点可查看详情

---

## Phase 3: 实时流传输

### 3.1 任务拆解

#### Task 3.1: 实现 WebSocket 广播
**文件**: `rust/agentflow-master/src/websocket/mod.rs`
**工作量**: 1 天

**实现内容**:
```rust
// websocket/mod.rs
use axum::{
    extract::{
        State,
        ws::{Message, WebSocket, WebSocketUpgrade},
    },
    response::IntoResponse,
};
use futures::{sink::SinkExt, stream::StreamExt};
use tokio::sync::broadcast;

#[derive(Clone)]
pub struct LogBroadcaster {
    tx: broadcast::Sender<LogLine>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogLine {
    pub level: String, // "user" | "think" | "bash" | "modify"
    pub content: String,
    pub timestamp: i64,
}

impl LogBroadcaster {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(100);
        Self { tx }
    }

    pub fn broadcast(&self, line: LogLine) {
        let _ = self.tx.send(line);
    }
}

pub async fn ws_handler(
    State(broadcaster): State<LogBroadcaster>,
    ws: WebSocketUpgrade,
) -> impl IntoResponse {
    ws.on_upgrade(|socket| handle_socket(socket, broadcaster))
}

async fn handle_socket(socket: WebSocket, broadcaster: LogBroadcaster) {
    let (mut sender, mut receiver) = socket.split();
    let mut rx = broadcaster.tx.subscribe();

    // 任务 1: 接收广播日志
    let send_task = tokio::spawn(async move {
        while let Ok(line) = rx.recv().await {
            let json = serde_json::to_string(&line).unwrap();
            if sender.send(Message::Text(json)).await.is_err() {
                break;
            }
        }
    });

    // 任务 2: 处理客户端消息（心跳等）
    let recv_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = receiver.next().await {
            match msg {
                Message::Close(_) => break,
                _ => {}
            }
        }
    });

    tokio::select! {
        _ = send_task => {},
        _ = recv_task => {},
    }
}
```

**验收标准**:
- WebSocket 连接建立成功
- 能接收广播消息

---

#### Task 3.2: 集成到 TaskExecutor
**文件**: `rust/agentflow-master/src/executor/mod.rs`
**工作量**: 1 天

**实现内容**:
```rust
// executor/mod.rs
use crate::websocket::LogBroadcaster;

impl TaskExecutor {
    pub async fn execute_with_streaming(
        &self,
        prompt: &str,
        broadcaster: &LogBroadcaster,
    ) -> Result<ExecutionResult> {
        // 启动 CLI 进程
        let mut child = Command::new("claude")
            .args(["--prompt", prompt])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let stdout = child.stdout.take().unwrap();
        let reader = BufReader::new(stdout);

        // 逐行读取并广播
        let mut lines = reader.lines();
        while let Some(Ok(line)) = lines.next().await {
            // 解析日志类型
            let level = if line.starts_with("[Bash]") {
                "bash".to_string()
            } else if line.starts_with("[File]") {
                "modify".to_string()
            } else {
                "think".to_string()
            };

            broadcaster.broadcast(LogLine {
                level,
                content: line.clone(),
                timestamp: Utc::now().timestamp(),
            });

            tracing::info!("{}", line);
        }

        // 等待进程结束
        let status = child.wait().await?;
        Ok(ExecutionResult {
            success: status.success(),
            output: "...".to_string(),
        })
    }
}
```

**验收标准**:
- CLI 日志实时推送到 WebSocket
- 不同类型日志带颜色标记

---

#### Task 3.3: 前端日志流组件
**文件**: `desktop/dashboard/src/components/LogStream.tsx`
**工作量**: 1 天

**实现内容**:
```tsx
import React, { useEffect, useRef } from 'react';
import { VirtualScroll } from 'react-virtualized';

interface LogLine {
  level: string;
  content: string;
  timestamp: number;
}

export const LogStream: React.FC = () => {
  const wsRef = useRef<WebSocket | null>(null);
  const [logs, setLogs] = useState<LogLine[]>([]);

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:6767/api/v1/stream');
    wsRef.current = ws;

    ws.onmessage = (event) => {
      const log: LogLine = JSON.parse(event.data);
      setLogs(prev => [...prev, log]);
    };

    return () => ws.close();
  }, []);

  const getLogColor = (level: string) => {
    switch (level) {
      case 'bash': return '#FFD700'; // 黄色
      case 'modify': return '#90EE90'; // 绿色
      case 'user': return '#FFFFFF'; // 白色
      default: return '#808080'; // 灰色
    }
  };

  return (
    <div style={{ backgroundColor: '#1E1E1E', padding: '16px' }}>
      {logs.map((log, index) => (
        <div
          key={index}
          style={{ color: getLogColor(log.level) }}
        >
          {log.content}
        </div>
      ))}
    </div>
  );
};
```

**验收标准**:
- 实时显示日志滚动
- 颜色区分清晰
- 无卡顿（虚拟滚动）

---

### 3.2 Phase 3 验收标准

- ✅ 实时显示 CLI 日志
- ✅ 颜色区分清晰
- ✅ 无性能问题

---

## Phase 4: 记忆可视化 (可选)

### 4.1 任务拆解

#### Task 4.1: 实现 Insights API
**文件**: `rust/agentflow-master/src/api/insights.rs`
**工作量**: 0.5 天

#### Task 4.2: 前端可视化
**文件**: `desktop/dashboard/src/components/Insights.tsx`
**工作量**: 1 天

#### Task 4.3: UI 美化
**工作量**: 0.5 天

---

## 风险与应对

| 风险 | 应对措施 |
|------|----------|
| Webhook 安全暴露 | Token + IP 白名单 + 速率限制 |
| 状态同步延迟 | WebSocket 推送代替轮询 |
| 大屏性能 | 虚拟滚动 + 频率限制 |
| CLI 崩溃 | 监控进程退出码，自动重试 |

---

## 下一步行动

### 立即执行

1. **创建分支**: `git checkout -b feature/0.3.0-phase1`
2. **实现 Webhook**: Task 1.1 - 1.3
3. **测试**: Task 1.4

### 技术预研

1. Tauri 入门：https://tauri.app/
2. Axum WebSocket: https://docs.rs/axum/latest/axum/extract/ws/index.html
3. React Flow: https://reactflow.dev/

---

**最后更新**: 2026-01-28
**文档版本**: 1.0
