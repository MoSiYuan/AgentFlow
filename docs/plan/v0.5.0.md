AgentFlow 分布式管理大屏需求文档（推送模式）
1. 项目概述
AgentFlow 管理大屏是一个基于事件驱动和推送机制的分布式系统监控与控制平台。该平台旨在解决多节点、多项目环境下的实时监控与协同问题。通过选举出的管理节点作为全局协调中心，利用 WebSocket/gRPC 流实现状态的实时推送，确保用户操作与系统变化的即时同步，闲时仅维持轻量级心跳。
2. 核心架构设计
2.1 整体拓扑
graph TD
    subgraph "云端"
        L[管理节点 - 集群Leader]
        A[Claude 智能体接入]
    end
    subgraph "集群"
        M1[Master 节点 1]
        M2[Master 节点 2]
        Mn[Master 节点 N]
    end
    subgraph "客户端"
        D1[管理大屏 1]
        D2[管理大屏 2]
    end
    %% 实时推送流
    M1 --"gRPC流: 状态上报"--> L
    M2 --"gRPC流: 状态上报"--> L
    Mn --"gRPC流: 状态上报"--> L
    L --"WebSocket: 全局状态广播"--> D1
    L --"WebSocket: 全局状态广播"--> D2
    D1 --"WebSocket: 指令下发"--> L
    D2 --"WebSocket: 指令下发"--> L
    L --"指令分发"--> M1
    L --"指令分发"--> M2
    %% 闲时心跳
    M1 -.->|心跳| L
    L -.->|心跳| M1
2.2 通信机制（核心策略）
实时推送流：
上行：Master 节点建立与 Leader 的长连接，一旦本地状态变更（任务开始/结束、卡顿、负载变化），立即推送事件给 Leader。
下行：Leader 维护前端 WebSocket 连接池，收到任何 Master 的更新后，立即广播给所有在线的大屏客户端。
闲时心跳：
在无状态变更时，连接双方每隔 30-60 秒交换一次轻量级 Ping/Pong，仅用于保活和探测连接存在，不携带业务状态数据。
3. 功能需求
3.1 分布式节点管理
服务注册与发现：节点启动时自动向 Leader 注册，汇报能力（GPU/OS/支持的项目类型）。
Leader 选举：云端部署时，首个节点或指定节点自动成为 Leader，负责统筹全局和接入 Claude。
独立访问与全局视图：每个 Master 节点可独立部署大屏，查看本地状态；同时通过 Leader 的推送，查看集群内其他节点的实时状态。
3.2 实时监控大屏（前端）
拓扑图：可视化展示 Leader、Master 及其关联的 Edge 节点，连线状态实时反映连接健康度。
状态仪表盘：
节点列表：展示 CPU/内存/磁盘实时数据（由各节点推送）。
任务队列：展示所有 Master 的待处理、运行中、已失败任务。
日志流：实时滚动显示各节点的关键日志（支持按节点/级别过滤）。
3.3 智能体对话控制
统一接入：Claude 仅接入 Leader 节点，避免多实例冲突。
上下文切换：前端界面提供下拉菜单，用户选择当前对话针对的“项目-节点”组合。Leader 根据选择路由指令。
指令执行：
用户在大屏输入：“暂停 Master-1 的编译任务”。
大屏 -> Leader -> Master-1 (gRPC) -> 返回结果 -> 推送给大屏。
卡顿主动反馈：
Master 检测到任务卡顿 -> 立即推送 StallEvent 给 Leader -> Leader 触发 Claude 分析 -> 对话窗口提示用户并提供解决方案。
3.4 数据管理
Agent 记忆检查：提供界面查看 Agent 当前的长期记忆和短期上下文。
工作日志：查询历史任务执行记录，支持从持久化数据库（SQLite）中拉取。
4. 技术栈与实现细节
4.1 后端
语言：Rust
框架：Axum (Web服务), Tokio (异步运行时)
通信：
tokio-tungstenite: 用于 Leader 与前端大屏的 WebSocket 连接。
tonic: 用于 Master 与 Leader 之间的 gRPC 双向流。
数据存储：SQLite (存储历史配置、日志), Redis (可选，用于 Leader 选举或 Session 缓存)。
4.2 前端
框架：React + TypeScript + Vite
UI：Tailwind CSS + Ant Design / Arco Design
状态管理：Redux Toolkit (处理接收到的实时推送事件更新 Store)
通信：原生 WebSocket API 或 Socket.IO Client
5. 数据协议设计
5.1 gRPC 流协议 (Master <-> Leader)
service NodeSync {
  // Master 建立流，持续接收 Leader 指令，同时发送状态更新
  rpc Connect (stream NodeUpdate) returns (stream LeaderCommand);
}
message NodeUpdate {
  string node_id = 1;
  int64 timestamp = 2;
  oneof payload {
    TaskStatusUpdate task_update = 3; // 任务变化
    SystemMetrics metrics = 4;       // 资源指标
    StallAlert alert = 5;           // 卡顿告警
  }
}
message LeaderCommand {
  string command_id = 1;
  oneof payload {
    TaskRequest task_request = 2;   // 下发新任务
    ControlSignal control = 3;      // 暂停/恢复/取消
  }
}
5.2 WebSocket 消息协议 (Frontend <-> Leader)
// 客户端 -> 服务端
type ClientMessage = 
  | { type: 'AUTH', token: string }
  | { type: 'CHAT', text: string, targetContext: string } // targetContext: "project1:master1"
  | { type: 'SUBSCRIBE', topics: string[] };
// 服务端 -> 客户端 (推送核心)
type ServerMessage = 
  | { type: 'NODE_STATUS', node: NodeStatus }
  | { type: 'TASK_UPDATE', task: TaskInfo }
  | { type: 'CHAT_RESPONSE', text: string }
  | { type: 'ALERT', level: 'error' | 'warning', message: string };
6. 任务分解（并行执行指引）
6.1 后端基础设施
Task-01: 定义 Protobuf 文件，生成 Rust gRPC 客户端和服务端代码。
Task-02: 实现 Axum 服务器基础框架，配置 CORS 和日志中间件。
Task-03: 实现基于内存的 Broadcaster 模块，用于管理 WebSocket 连接池并广播消息。
6.2 核心通信逻辑
Task-04: 实现 Leader 节点的 gRPC 服务端，处理 Master 的连接流和消息解析。
Task-05: 实现 Master 节点的 gRPC 客户端，启动时连接 Leader，并封装 send_update 方法。
Task-06: 实现 WebSocket 路由，处理前端连接、认证和心跳保活。
6.3 业务逻辑实现
Task-07: 开发任务调度器（Leader端），解析 Claude 指令并转换为 gRPC 消息下发给指定 Master。
Task-08: 开发监控采集器，定期收集系统负载（非闲时心跳，而是在变化时推送，或定期低频推送），封装为 SystemMetrics。
Task-09: 实现卡顿检测逻辑（Master端），一旦检测到立即通过 gRPC 流发送 StallAlert。
6.4 前端开发
Task-10: 搭建 React 项目，集成 Tailwind CSS 和 Redux。
Task-11: 实现 WebSocket 封装 Hook (useWebSocket)，处理重连和消息分发。
Task-12: 开发监控大屏布局：左侧节点拓扑图（使用 React Flow），右侧任务列表，底部日志流。
Task-13: 开发 Claude 对话组件，实现当前上下文（Target Node）的切换逻辑。
6.5 集成与测试
Task-14: 编写 Docker Compose 文件，模拟 1 个 Leader + 2 个 Master 的本地集群环境。
Task-15: 端到端测试：在 Master 1 触发模拟卡顿，验证大屏是否实时收到告警；在大屏发送控制指令，验证 Master 1 是否执行。
7. 交付清单
后端代码库：包含 Leader 和 Master 两种运行模式的 Rust 工程。
前端代码库：React 工程及构建产物。
API 定义：.proto 文件及 WebSocket 接口文档。
部署指南：如何配置 Leader 地址、如何启动不同模式的节点。
此方案完全摒弃了轮询，采用全推模式，能够最大程度保证低延迟和高实时性，满足“用户操作即时反馈”和“卡顿即时告警”的强需求。