package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/jiangxiaolong/agentflow-go/internal/database"
	"github.com/jiangxiaolong/agentflow-go/internal/master"
	"github.com/jiangxiaolong/agentflow-go/internal/worker"
)

const version = "1.0.0"

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := os.Args[1]

	switch command {
	case "init":
		if len(os.Args) < 3 {
			fmt.Println("ç”¨æ³•: agentflow init <æ•°æ®åº“æ–‡ä»¶>")
			os.Exit(1)
		}
		initDatabase(os.Args[2])

	case "master":
		runMaster()

	case "worker":
		runWorker()

	case "add":
		if len(os.Args) < 3 {
			fmt.Println("ç”¨æ³•: agentflow add <ä»»åŠ¡æ ‡é¢˜>")
			os.Exit(1)
		}
		addTask(os.Args[2])

	case "list":
		listTasks()

	case "workers":
		listWorkers()

	case "version":
		fmt.Printf("AgentFlow version %s\n", version)

	default:
		fmt.Printf("æœªçŸ¥å‘½ä»¤: %s\n", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println(`
AgentFlow - AI Agent Task Collaboration System
ç‰ˆæœ¬: 1.0.0

ç”¨æ³•:
  agentflow <å‘½ä»¤> [å‚æ•°]

å‘½ä»¤:
  init <db>          åˆå§‹åŒ–æ•°æ®åº“
  master             å¯åŠ¨ Master æœåŠ¡
  worker             å¯åŠ¨ Worker
  add <ä»»åŠ¡>         æ·»åŠ ä»»åŠ¡
  list               åˆ—å‡ºä»»åŠ¡
  workers            åˆ—å‡º Worker
  version            æ˜¾ç¤ºç‰ˆæœ¬

ç¤ºä¾‹:
  # åˆå§‹åŒ–
  agentflow init agentflow.db

  # å¯åŠ¨ Master
  agentflow master --db agentflow.db

  # å¯åŠ¨ Worker
  agentflow worker --master http://localhost:8848 --group windows

  # æ·»åŠ ä»»åŠ¡
  agentflow add "å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½"

  # æŸ¥çœ‹çŠ¶æ€
  agentflow list

ç¯å¢ƒå˜é‡:
  MASTER_URL    Master åœ°å€ (é»˜è®¤: http://localhost:8848)
  WORKER_GROUP  Worker ç»„å
`)
}

func initDatabase(dbPath string) {
	db, err := database.NewDatabase(dbPath)
	if err != nil {
		fmt.Printf("âŒ æ‰“å¼€æ•°æ®åº“å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	if err := db.Init(); err != nil {
		fmt.Printf("âŒ åˆå§‹åŒ–å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: %s\n", dbPath)
}

func runMaster() {
	fs := flag.NewFlagSet("master", flag.ExitOnError)
	dbPath := fs.String("db", "agentflow.db", "æ•°æ®åº“æ–‡ä»¶è·¯å¾„")
	host := fs.String("host", "0.0.0.0", "ç›‘å¬åœ°å€")
	port := fs.Int("port", 8848, "ç›‘å¬ç«¯å£")
	autoStart := fs.Bool("auto-start", true, "è‡ªåŠ¨å¯åŠ¨æœ¬åœ° workers")

	if err := fs.Parse(os.Args[2:]); err != nil {
		fmt.Printf("âŒ å‚æ•°è§£æå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	cfg := &master.Config{
		DBPath:    *dbPath,
		Host:      *host,
		Port:      *port,
		AutoStart: *autoStart,
	}

	m, err := master.New(cfg)
	if err != nil {
		fmt.Printf("âŒ åˆ›å»º Master å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer m.Close()

	// Setup signal handling
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-sigCh
		fmt.Println("\næ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨å…³é—­...")
		m.Close()
		os.Exit(0)
	}()

	addr := fmt.Sprintf("%s:%d", *host, *port)
	if err := m.Run(addr); err != nil {
		fmt.Printf("âŒ Master è¿è¡Œå¤±è´¥: %v\n", err)
		os.Exit(1)
	}
}

func runWorker() {
	fs := flag.NewFlagSet("worker", flag.ExitOnError)
	masterURL := fs.String("master", "http://localhost:8848", "Master åœ°å€")
	dbPath := fs.String("db", "", "æ•°æ®åº“æ–‡ä»¶è·¯å¾„ (æœ¬åœ°æ¨¡å¼)")
	groupName := fs.String("group", "", "å·¥ä½œç»„åç§°")
	workerID := fs.String("worker-id", "", "Worker ID")

	if err := fs.Parse(os.Args[2:]); err != nil {
		fmt.Printf("âŒ å‚æ•°è§£æå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	// Get defaults from environment
	if *masterURL == "" {
		*masterURL = os.Getenv("MASTER_URL")
		if *masterURL == "" {
			*masterURL = "http://localhost:8848"
		}
	}

	if *groupName == "" {
		*groupName = os.Getenv("WORKER_GROUP")
	}

	cfg := &worker.Config{
		ID:        *workerID,
		MasterURL: *masterURL,
		DBPath:    *dbPath,
		GroupName: *groupName,
	}

	w, err := worker.New(cfg)
	if err != nil {
		fmt.Printf("âŒ åˆ›å»º Worker å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer w.Stop()

	// Setup signal handling
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-sigCh
		fmt.Println("\næ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨å…³é—­...")
		cancel()
		w.Stop()
	}()

	if err := w.Run(ctx); err != nil && err != context.Canceled {
		fmt.Printf("âŒ Worker è¿è¡Œå¤±è´¥: %v\n", err)
		os.Exit(1)
	}
}

func addTask(title string) {
	fs := flag.NewFlagSet("add", flag.ExitOnError)
	dbPath := fs.String("db", "agentflow.db", "æ•°æ®åº“æ–‡ä»¶è·¯å¾„")
	description := fs.String("desc", "", "ä»»åŠ¡æè¿°")
	groupName := fs.String("group", "default", "å·¥ä½œç»„åç§°")
	completionCriteria := fs.String("criteria", "", "å®Œæˆæ ‡å‡†")

	if err := fs.Parse(os.Args[2:]); err != nil {
		fmt.Printf("âŒ å‚æ•°è§£æå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	db, err := database.NewDatabase(*dbPath)
	if err != nil {
		fmt.Printf("âŒ æ‰“å¼€æ•°æ®åº“å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	taskID, err := db.CreateTask(title, *description, *groupName, *completionCriteria)
	if err != nil {
		fmt.Printf("âŒ æ·»åŠ ä»»åŠ¡å¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("âœ… ä»»åŠ¡å·²åˆ›å»º\n")
	fmt.Printf("   ID: %s\n", taskID)
	fmt.Printf("   æ ‡é¢˜: %s\n", title)
	fmt.Printf("   å·¥ä½œç»„: %s\n", *groupName)
}

func listTasks() {
	fs := flag.NewFlagSet("list", flag.ExitOnError)
	dbPath := fs.String("db", "agentflow.db", "æ•°æ®åº“æ–‡ä»¶è·¯å¾„")
	status := fs.String("status", "", "è¿‡æ»¤çŠ¶æ€ (pending/running/completed/failed)")
	groupName := fs.String("group", "", "è¿‡æ»¤å·¥ä½œç»„")

	if err := fs.Parse(os.Args[2:]); err != nil {
		fmt.Printf("âŒ å‚æ•°è§£æå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	db, err := database.NewDatabase(*dbPath)
	if err != nil {
		fmt.Printf("âŒ æ‰“å¼€æ•°æ®åº“å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	tasks, err := db.ListTasks(*status, *groupName)
	if err != nil {
		fmt.Printf("âŒ è·å–ä»»åŠ¡åˆ—è¡¨å¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	if len(tasks) == 0 {
		fmt.Println("æ²¡æœ‰ä»»åŠ¡")
		return
	}

	fmt.Printf("\nå…±æœ‰ %d ä¸ªä»»åŠ¡\n\n", len(tasks))
	for _, task := range tasks {
		statusIcon := "â³"
		switch task.Status {
		case "pending":
			statusIcon = "â³"
		case "running":
			statusIcon = "â–¶ï¸"
		case "completed":
			statusIcon = "âœ…"
		case "failed":
			statusIcon = "âŒ"
		}

		fmt.Printf("%s [%s] %s\n", statusIcon, task.ID, task.Title)
		fmt.Printf("   å·¥ä½œç»„: %s\n", task.GroupName)
		fmt.Printf("   çŠ¶æ€: %s\n", task.Status)
		if task.LockHolder != "" {
			fmt.Printf("   æ‰§è¡Œè€…: %s\n", task.LockHolder)
		}
		fmt.Printf("   åˆ›å»ºæ—¶é—´: %s\n", task.CreatedAt.Format("2006-01-02 15:04:05"))
		fmt.Println()
	}
}

func listWorkers() {
	fs := flag.NewFlagSet("workers", flag.ExitOnError)
	dbPath := fs.String("db", "agentflow.db", "æ•°æ®åº“æ–‡ä»¶è·¯å¾„")
	groupName := fs.String("group", "", "è¿‡æ»¤å·¥ä½œç»„")

	if err := fs.Parse(os.Args[2:]); err != nil {
		fmt.Printf("âŒ å‚æ•°è§£æå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	db, err := database.NewDatabase(*dbPath)
	if err != nil {
		fmt.Printf("âŒ æ‰“å¼€æ•°æ®åº“å¤±è´¥: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	workers, err := db.ListWorkers(*groupName)
	if err != nil {
		fmt.Printf("âŒ è·å– Worker åˆ—è¡¨å¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	if len(workers) == 0 {
		fmt.Println("æ²¡æœ‰ Worker")
		return
	}

	fmt.Printf("\nå…±æœ‰ %d ä¸ª Worker\n\n", len(workers))
	for _, w := range workers {
		statusIcon := "ğŸŸ¢"
		if w.Status != "active" {
			statusIcon = "ğŸ”´"
		}

		// Check if heartbeat is recent
		if time.Since(w.LastHeartbeat) > 2*time.Minute {
			statusIcon = "âš ï¸"
		}

		fmt.Printf("%s [%s] %s\n", statusIcon, w.ID, w.Type)
		fmt.Printf("   å·¥ä½œç»„: %s\n", w.GroupName)
		fmt.Printf("   çŠ¶æ€: %s\n", w.Status)
		fmt.Printf("   æœ€åå¿ƒè·³: %s\n", w.LastHeartbeat.Format("2006-01-02 15:04:05"))
		fmt.Println()
	}
}
